
#pragma once

/* This file is auto-generated by the script 'glue_generator.py'.
 * Do not edit this file by hand.
 */

#include <stddef.h>
#include <unordered_map>
#include <functional>
#include <string>
#include <cstring>

#define GLUE_ERR_OUT_OF_RANGE -900001

template <typename T>
class Glue
{
  T* parent_;
  typedef void (*cb_int32_t)(void*, size_t, int);
  typedef void (*cb_float64_t)(void*, size_t, double);
  typedef void (*cb_string_t)(void*, size_t, const char*);
  typedef void (*cb_enum_t)(void*, size_t, int);
  typedef void (*cb_arr1d_t)(void*, size_t, size_t arr_len_in_bytes, void* data);
  typedef void (*cb_arr2d_t)(void*, size_t, size_t arr_len_in_bytes,
                                    size_t width, void* data);
  template <typename CBType>
  struct RegCallback
  {
    RegCallback() : priv(nullptr), cb(nullptr) {}
    RegCallback(void* p, CBType c) : priv(p), cb(c) {}
    void set(void* p, CBType c) { priv = p; cb = c; }
    void* priv;
    CBType cb;
  };
  RegCallback<cb_int32_t> cb_int32;
  RegCallback<cb_float64_t> cb_float64;
  RegCallback<cb_string_t> cb_string;
  RegCallback<cb_enum_t> cb_enum;
  RegCallback<cb_arr1d_t> cb_arr1d;
  RegCallback<cb_arr2d_t> cb_arr2d;
  // define member function signatures for the T class
  typedef int (T::*write_int_member_fun_t) (int);
  typedef int (T::*write_float64_member_fun_t) (double);
  typedef int (T::*write_string_member_fun_t) (const std::string&);
  typedef int (T::*read_int_member_fun_t) (int*);
  typedef int (T::*read_float64_member_fun_t) (double*);
  typedef int (T::*read_string_member_fun_t) (std::string&);
  std::unordered_map<size_t, write_int_member_fun_t> write_int_funs;
  std::unordered_map<size_t, write_int_member_fun_t> write_enum_funs;
  std::unordered_map<size_t, write_float64_member_fun_t> write_float64_funs;
  std::unordered_map<size_t, write_string_member_fun_t> write_string_funs;
  std::unordered_map<size_t, read_int_member_fun_t> read_int_funs;
  std::unordered_map<size_t, read_int_member_fun_t> read_enum_funs;
  std::unordered_map<size_t, read_float64_member_fun_t> read_float64_funs;
  std::unordered_map<size_t, read_string_member_fun_t> read_string_funs;

public:
  Glue(T* parent) : parent_(parent) {
    cb_int32.cb = [](void*, size_t, int) { };
    cb_float64.cb = [](void*, size_t, double) { };
    cb_string.cb = [](void*, size_t, const char*) { };
    cb_enum.cb = [](void*, size_t, int) { };
    /* ---------- */
    write_enum_funs.insert({0, &T::write_Initialize});
    read_enum_funs.insert({0, &T::read_Initialize});
    write_string_funs.insert({1, &T::write_ConfigFile});
    read_string_funs.insert({1, &T::read_ConfigFile});
    read_string_funs.insert({2, &T::read_StatusMessage});
    read_enum_funs.insert({3, &T::read_DetectorState});
    write_float64_funs.insert({4, &T::write_Exposure});
    read_float64_funs.insert({4, &T::read_Exposure});
    write_float64_funs.insert({5, &T::write_AcquirePeriod});
    read_float64_funs.insert({5, &T::read_AcquirePeriod});
    write_enum_funs.insert({6, &T::write_Acquire});
    read_enum_funs.insert({6, &T::read_Acquire});
    write_enum_funs.insert({7, &T::write_ImageMode});
    read_enum_funs.insert({7, &T::read_ImageMode});
    write_int_funs.insert({8, &T::write_NumImages});
    read_int_funs.insert({8, &T::read_NumImages});
    read_int_funs.insert({9, &T::read_NumImagesCounter});
    write_int_funs.insert({10, &T::write_BinX});
    read_int_funs.insert({10, &T::read_BinX});
    write_int_funs.insert({11, &T::write_BinY});
    read_int_funs.insert({11, &T::read_BinY});
    write_int_funs.insert({12, &T::write_MinX});
    read_int_funs.insert({12, &T::read_MinX});
    write_int_funs.insert({13, &T::write_MinY});
    read_int_funs.insert({13, &T::read_MinY});
    write_int_funs.insert({14, &T::write_SizeX});
    read_int_funs.insert({14, &T::read_SizeX});
    write_int_funs.insert({15, &T::write_SizeY});
    read_int_funs.insert({15, &T::read_SizeY});
  }

  int write_int(size_t pidx, int value) {
    try {
      return std::invoke(write_int_funs.at(pidx), parent_, value);
    } catch (const std::out_of_range&) {
      return GLUE_ERR_OUT_OF_RANGE;
    }
  }
  int write_float64(size_t pidx, double value) {
    try {
      return std::invoke(write_float64_funs.at(pidx), parent_, value);
    } catch (const std::out_of_range&) {
      return GLUE_ERR_OUT_OF_RANGE;
    }
  }
  int write_enum(size_t pidx, int value) {
    try {
      return std::invoke(write_enum_funs.at(pidx), parent_, value);
    } catch (const std::out_of_range&) {
      return GLUE_ERR_OUT_OF_RANGE;
    }
  }
  int write_string(size_t pidx, const char* value) {
    try {
      return std::invoke(write_string_funs.at(pidx), parent_, value);
    } catch (const std::out_of_range&) {
      return GLUE_ERR_OUT_OF_RANGE;
    }
  }
  int read_int(size_t pidx, int* dest) {
    try {
      return std::invoke(read_int_funs.at(pidx), parent_, dest);
    } catch (const std::out_of_range&) {
      return GLUE_ERR_OUT_OF_RANGE;
    }
  }
  int read_float64(size_t pidx, double* dest) {
    try {
      return std::invoke(read_float64_funs.at(pidx), parent_, dest);
    } catch (const std::out_of_range&) {
      return GLUE_ERR_OUT_OF_RANGE;
    }
  }
  int read_enum(size_t pidx, int* dest) {
    try {
      return std::invoke(read_enum_funs.at(pidx), parent_, dest);
    } catch (const std::out_of_range&) {
      return GLUE_ERR_OUT_OF_RANGE;
    }
  }
  int read_string(size_t pidx, size_t* len, char* value) {
    try {
      std::string s;
      int ret = std::invoke(read_string_funs.at(pidx), parent_, s);
      if (ret < 0) return ret;
      if (len != nullptr && value == nullptr) {
        *len = s.size()+1;
      }
      else if (len != nullptr && value != nullptr) {
        strncpy(value, s.c_str(), (*len)-1);
        value[(*len)-1] = 0;
      }
      return ret;
    } catch (const std::out_of_range&) {
      return GLUE_ERR_OUT_OF_RANGE;
    }
  }
  int set_callback_int32(void* priv, cb_int32_t cb) { cb_int32.set(priv, cb); return 0; }
  int set_callback_float64(void* priv, cb_float64_t cb) { cb_float64.set(priv, cb); return 0; }
  int set_callback_string(void* priv, cb_string_t cb) { cb_string.set(priv, cb); return 0; }
  int set_callback_enum(void* priv, cb_enum_t cb) { cb_enum.set(priv, cb); return 0; }
  int set_callback_arr1d(void* priv, cb_arr1d_t cb) { cb_arr1d.set(priv, cb); return 0; }
  int set_callback_arr2d(void* priv, cb_arr2d_t cb) { cb_arr2d.set(priv, cb); return 0; }
  void update_Initialize(int v) { cb_enum.cb(cb_enum.priv, 0, v); }
  void update_ConfigFile(const std::string& v) { cb_string.cb(cb_string.priv, 1, v.c_str()); }
  void update_StatusMessage(const std::string& v) { cb_string.cb(cb_string.priv, 2, v.c_str()); }
  void update_DetectorState(int v) { cb_enum.cb(cb_enum.priv, 3, v); }
  void update_Exposure(double v) { cb_float64.cb(cb_float64.priv, 4, v); }
  void update_AcquirePeriod(double v) { cb_float64.cb(cb_float64.priv, 5, v); }
  void update_Acquire(int v) { cb_enum.cb(cb_enum.priv, 6, v); }
  void update_ImageMode(int v) { cb_enum.cb(cb_enum.priv, 7, v); }
  void update_NumImages(int v) { cb_int32.cb(cb_int32.priv, 8, v); }
  void update_NumImagesCounter(int v) { cb_int32.cb(cb_int32.priv, 9, v); }
  void update_BinX(int v) { cb_int32.cb(cb_int32.priv, 10, v); }
  void update_BinY(int v) { cb_int32.cb(cb_int32.priv, 11, v); }
  void update_MinX(int v) { cb_int32.cb(cb_int32.priv, 12, v); }
  void update_MinY(int v) { cb_int32.cb(cb_int32.priv, 13, v); }
  void update_SizeX(int v) { cb_int32.cb(cb_int32.priv, 14, v); }
  void update_SizeY(int v) { cb_int32.cb(cb_int32.priv, 15, v); }
  void update_Ratemeter(size_t nr_elem, int* data) { 
    cb_arr1d.cb(cb_arr1d.priv, 16, nr_elem*sizeof(int), data); }
  void update_LiveImageXY(size_t nr_elem, size_t width, int* data) {
    cb_arr2d.cb(cb_arr2d.priv, 17, nr_elem*sizeof(int), width, data); }

};
